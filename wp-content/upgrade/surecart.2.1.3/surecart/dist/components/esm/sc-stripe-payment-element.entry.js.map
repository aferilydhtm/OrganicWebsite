{"file":"sc-stripe-payment-element.entry.js","mappings":";;;;;;;;AAAA,MAAM,yBAAyB,GAAG,mQAAmQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0EC0FlQ,UAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgNrC;;;;;","names":[],"sources":["./src/components/ui/stripe-payment-element/sc-stripe-payment-element.scss?tag=sc-stripe-payment-element","./src/components/ui/stripe-payment-element/sc-stripe-payment-element.tsx"],"sourcesContent":["sc-stripe-payment-element {\n  display: block;\n\n  [hidden] {\n    display: none;\n  }\n}\n\n.loader {\n  display: grid;\n  height: 128px;\n  gap: 2em;\n\n  &__row {\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    gap: 1em;\n  }\n\n  &__details {\n    display: grid;\n    gap: 0.5em;\n  }\n}\n","import { Component, Element, Event, EventEmitter, h, Method, Prop, State, Watch } from '@stencil/core';\nimport { Stripe } from '@stripe/stripe-js';\nimport { loadStripe } from '@stripe/stripe-js/pure';\nimport { __ } from '@wordpress/i18n';\nimport { addQueryArgs } from '@wordpress/url';\nimport { openWormhole } from 'stencil-wormhole';\nimport { state as selectedProcessor } from '@store/selected-processor';\n\nimport { Checkout, FormState, FormStateSetter, PaymentIntent, ProcessorName, ShippingAddress } from '../../../types';\n\n@Component({\n  tag: 'sc-stripe-payment-element',\n  styleUrl: 'sc-stripe-payment-element.scss',\n  shadow: false,\n})\nexport class ScStripePaymentElement {\n  @Element() el: HTMLScStripePaymentElementElement;\n  /** Holds the element container. */\n  private container: HTMLDivElement;\n  // holds the elements instance.\n  private elements: any;\n  // holds the stripe element.\n  private element: any;\n  // holds the stripe instance.\n  private stripe: Stripe;\n\n  /** The Payment Intent */\n  @Prop() stripePaymentIntent: PaymentIntent;\n\n  /** Order to watch */\n  @Prop() order: Checkout;\n\n  /** Should we collect an address? */\n  @Prop() address: boolean;\n\n  /** Success url to redirect. */\n  @Prop() successUrl: string;\n\n  /** The current form state. */\n  @Prop() formState: FormState;\n\n  /** The selected processor name. */\n  @Prop() selectedProcessorId: ProcessorName;\n\n  /** The error. */\n  @State() error: string;\n\n  /** Is this yet loaded. */\n  @State() loaded: boolean = false;\n\n  /** Are we confirming the order? */\n  @State() confirming: boolean = false;\n\n  /** The order/invoice was paid for. */\n  @Event() scPaid: EventEmitter<void>;\n\n  /** There was a payment error. */\n  @Event() scPayError: EventEmitter<any>;\n  /** Set the state */\n  @Event() scSetState: EventEmitter<FormStateSetter>;\n\n  /** Maybe load the stripe element on load. */\n  async componentDidLoad() {\n    this.initialize();\n  }\n\n  @Watch('stripePaymentIntent')\n  handleUpdatedChange(val, prev) {\n    this.error = '';\n\n    // client secret changed, reload the element\n    if (val?.processor_data?.stripe?.client_secret !== prev?.processor_data?.stripe?.client_secret) {\n      return this.initialize();\n    }\n\n    // otherwise, fetch element updates.\n    this.elements.fetchUpdates();\n  }\n\n  async initialize() {\n    // we need this data.\n    if (!this.stripePaymentIntent?.processor_data?.stripe?.publishable_key || !this.stripePaymentIntent?.processor_data?.stripe?.account_id) return;\n\n    // check if stripe has been initialized\n    if (!this.stripe) {\n      try {\n        this.stripe = await loadStripe(this.stripePaymentIntent?.processor_data?.stripe?.publishable_key, {\n          stripeAccount: this.stripePaymentIntent?.processor_data?.stripe?.account_id,\n        });\n      } catch (e) {\n        this.error = e?.message || __('Stripe could not be loaded', 'surecart');\n        // don't continue.\n        return;\n      }\n    }\n\n    // load the element.\n    this.loadElement();\n  }\n\n  @Watch('order')\n  @Watch('error')\n  handleUpdateElement() {\n    if (!this.element) return;\n    if (this.order?.status !== 'draft') return;\n    const { name, email } = this.order;\n    const { line_1: line1, line_2: line2, city, state, country, postal_code } = (this.order?.shipping_address as ShippingAddress) || {};\n    this.element.update({\n      defaultValues: {\n        billingDetails: {\n          name,\n          email,\n          address: {\n            line1,\n            line2,\n            city,\n            state,\n            country,\n            postal_code,\n          },\n        },\n      },\n      fields: {\n        billingDetails: {\n          email: 'never',\n        },\n      },\n    });\n    this.elements.fetchUpdates();\n  }\n\n  /**\n   * Watch order status and maybe confirm the order.\n   */\n  @Watch('formState')\n  async maybeConfirmOrder(val: FormState) {\n    // must be finalized\n    if (val !== 'paying') return;\n    // this processor is not selected.\n    if (selectedProcessor?.id !== 'stripe') return;\n    // must be a stripe session\n    if (this.order?.payment_intent?.processor_type !== 'stripe') return;\n    // need an external_type\n    if (!this.order?.payment_intent?.processor_data?.stripe?.type) return;\n    // confirm the intent.\n    return await this.confirm(this.order?.payment_intent?.processor_data?.stripe?.type);\n  }\n\n  @Method()\n  async confirm(type, args = {}) {\n    const confirmArgs = {\n      elements: this.elements,\n      confirmParams: {\n        return_url: addQueryArgs(window.location.href, {\n          ...(this.order.id ? { checkout_id: this.order.id } : {}),\n        }),\n        payment_method_data: {\n          billing_details: {\n            email: this.order.email,\n          },\n        },\n      },\n      redirect: 'if_required',\n      ...args,\n    };\n\n    // prevent possible double-charges\n    if (this.confirming) return;\n\n    // stripe must be loaded.\n    if (!this.stripe) return;\n\n    try {\n      this.scSetState.emit('PAYING');\n      const response = type === 'setup' ? await this.stripe.confirmSetup(confirmArgs as any) : await this.stripe.confirmPayment(confirmArgs as any);\n      if (response?.error) {\n        this.error = response.error.message;\n        throw response.error;\n      }\n      this.scSetState.emit('PAID');\n      // paid\n      this.scPaid.emit();\n    } catch (e) {\n      console.error(e);\n      this.scPayError.emit(e);\n      if (e.message) {\n        this.error = e.message;\n      }\n    } finally {\n      this.confirming = false;\n    }\n  }\n\n  loadElement() {\n    // we need a stripe instance and client secret.\n    if (!this.stripe || !this.stripePaymentIntent?.processor_data?.stripe?.client_secret || !this.container) {\n      console.log('do not have stripe or');\n      return;\n    }\n\n    // get the computed styles.\n    const styles = getComputedStyle(this.el);\n\n    // we have what we need, load elements.\n    this.elements = this.stripe.elements({\n      clientSecret: this.stripePaymentIntent?.processor_data?.stripe?.client_secret,\n      appearance: {\n        variables: {\n          colorPrimary: styles.getPropertyValue('--sc-color-primary-500'),\n          colorText: styles.getPropertyValue('--sc-input-label-color'),\n          borderRadius: styles.getPropertyValue('--sc-input-border-radius-medium'),\n          colorBackground: styles.getPropertyValue('--sc-input-background-color'),\n          fontSizeBase: styles.getPropertyValue('--sc-input-font-size-medium'),\n          colorLogo: styles.getPropertyValue('--sc-stripe-color-logo'),\n          colorLogoTab: styles.getPropertyValue('--sc-stripe-color-logo-tab'),\n          colorLogoTabSelected: styles.getPropertyValue('--sc-stripe-color-logo-tab-selected'),\n          colorTextPlaceholder: styles.getPropertyValue('--sc-input-placeholder-color'),\n        },\n        rules: {\n          '.Input': {\n            border: styles.getPropertyValue('--sc-input-border'),\n          },\n        },\n      },\n    });\n\n    const { line_1: line1, line_2: line2, city, state, country, postal_code } = (this.order?.shipping_address as ShippingAddress) || {};\n\n    // create the payment element.\n    this.elements\n      .create('payment', {\n        defaultValues: {\n          billingDetails: {\n            name: this.order?.name,\n            email: this.order?.email,\n            address: {\n              line1,\n              line2,\n              city,\n              state,\n              country,\n              postal_code,\n            },\n          },\n        },\n        fields: {\n          billingDetails: {\n            email: 'never',\n          },\n        },\n      })\n      .mount('.sc-payment-element-container');\n\n    this.element = this.elements.getElement('payment');\n    this.element.on('ready', () => (this.loaded = true));\n  }\n\n  render() {\n    return (\n      <div class=\"sc-stripe-payment-element\" data-testid=\"stripe-payment-element\">\n        {!!this.error && (\n          <sc-text\n            style={{\n              'color': 'var(--sc-color-danger-500)',\n              '--font-size': 'var(--sc-font-size-small)',\n              'marginBottom': '0.5em',\n            }}\n          >\n            {this.error}\n          </sc-text>\n        )}\n\n        <div class=\"loader\" hidden={this.loaded}>\n          <div class=\"loader__row\">\n            <div style={{ width: '50%' }}>\n              <sc-skeleton style={{ width: '50%', marginBottom: '0.5em' }}></sc-skeleton>\n              <sc-skeleton></sc-skeleton>\n            </div>\n            <div style={{ flex: '1' }}>\n              <sc-skeleton style={{ width: '50%', marginBottom: '0.5em' }}></sc-skeleton>\n              <sc-skeleton></sc-skeleton>\n            </div>\n            <div style={{ flex: '1' }}>\n              <sc-skeleton style={{ width: '50%', marginBottom: '0.5em' }}></sc-skeleton>\n              <sc-skeleton></sc-skeleton>\n            </div>\n          </div>\n          <div class=\"loader__details\">\n            <sc-skeleton style={{ height: '1rem' }}></sc-skeleton>\n            <sc-skeleton style={{ height: '1rem', width: '30%' }}></sc-skeleton>\n          </div>\n        </div>\n        <div hidden={!this.loaded} class=\"sc-payment-element-container\" ref={el => (this.container = el as HTMLDivElement)}></div>\n      </div>\n    );\n  }\n}\n\nopenWormhole(ScStripePaymentElement, ['order', 'selectedProcessorId', 'stripePaymentIntent', 'formState'], true);\n"],"version":3}