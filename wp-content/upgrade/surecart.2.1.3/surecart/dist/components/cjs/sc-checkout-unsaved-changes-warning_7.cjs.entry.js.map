{"file":"sc-checkout-unsaved-changes-warning.sc-form-components-validator.sc-form-error-provider.sc-form-state-provider.sc-login-provider.sc-order-confirm-provider.sc-session-provider.entry.cjs.js","mappings":"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","names":["h","interpret","checkoutMachine","state"],"sources":["./src/components/providers/checkout-unsaved-changes-warning/sc-checkout-unsaved-changes-warning.tsx","./src/components/providers/form-components-validator/sc-form-components-validator.tsx","./src/components/providers/form-error-provider/sc-form-error-provider.tsx","./src/store/form/watchers.ts","./src/store/form/mutations.ts","./src/components/providers/form-state-provider/sc-form-state-provider.tsx","./src/components/providers/sc-login-provider/sc-login-provider.css?tag=sc-login-provider&encapsulation=shadow","./src/components/providers/sc-login-provider/sc-login-provider.tsx","./src/components/providers/order-confirm-provider/sc-order-confirm-provider.scss?tag=sc-order-confirm-provider&encapsulation=shadow","./src/components/providers/order-confirm-provider/sc-order-confirm-provider.tsx","./src/components/providers/session-provider/sc-session-provider.tsx"],"sourcesContent":["import { Component, Prop } from '@stencil/core';\nimport { __ } from '@wordpress/i18n';\nimport { FormState } from '../../../types';\n\n@Component({\n  tag: 'sc-checkout-unsaved-changes-warning',\n  shadow: true,\n})\nexport class ScCheckoutUnsavedChangesWarning {\n  @Prop() state: FormState;\n\n  /**\n   * Add event listener for beforeunload.\n   */\n  componentDidLoad() {\n    window.addEventListener('beforeunload', e => this.warnIfUnsavedChanges(e), { capture: true });\n  }\n\n  /**\n   * Warn if status is updaing, finalizing, paying or confirming.\n   */\n  warnIfUnsavedChanges(e) {\n    if (['updating', 'finalizing', 'confirming'].includes(this.state)) {\n      console.log({ e });\n      e.preventDefault();\n      e.returnValue = __('Your payment is processing. Exiting this page could cause an error in your order. Please do not navigate away from this page.', 'surecart');\n      return e.returnValue;\n    }\n  }\n}\n","import { Component, Element, h, Prop, State, Watch } from '@stencil/core';\nimport { __ } from '@wordpress/i18n';\n\nimport { Checkout, TaxProtocol } from '../../../types';\n\n@Component({\n  tag: 'sc-form-components-validator',\n  shadow: true,\n})\nexport class ScFormComponentsValidator {\n  @Element() el: HTMLScFormComponentsValidatorElement;\n\n  /** Disable validation? */\n  @Prop() disabled: boolean;\n\n  /** The order */\n  @Prop() order: Checkout;\n\n  /** The tax protocol */\n  @Prop() taxProtocol: TaxProtocol;\n\n  /** Is there an address field? */\n  @State() hasAddress: boolean;\n\n  /** Is there a tax id field? */\n  @State() hasTaxIDField: boolean;\n\n  /** Is there a bumps field? */\n  @State() hasBumpsField: boolean;\n\n  /** Is there a tax line? */\n  @State() hasTaxLine: boolean;\n\n  /** Is there a bump line? */\n  @State() hasBumpLine: boolean;\n\n  @Watch('order')\n  handleOrderChange() {\n    // bail if we don't have address invalid error or disabled.\n    if (this.disabled) return;\n    // make sure to add the address field if it's not there.\n    if (this?.order?.tax_status === 'address_invalid' || this?.order?.shipping_enabled) {\n      this.addAddressField();\n    }\n    // add order bumps.\n    if (this?.order?.recommended_bumps?.data?.length) {\n      this.addBumps();\n    }\n    if (!!this.order?.tax_amount) {\n      this.addTaxLine();\n    }\n  }\n\n  componentWillLoad() {\n    this.hasAddress = !!this.el.querySelector('sc-order-shipping-address');\n    this.hasTaxIDField = !!this.el.querySelector('sc-order-tax-id-input');\n    this.hasBumpsField = !!this.el.querySelector('sc-order-bumps');\n    this.hasTaxLine = !!this.el.querySelector('sc-line-item-tax');\n\n    // automatically add address field if tax is enabled.\n    if (this.taxProtocol?.tax_enabled) {\n      this.addAddressField();\n\n      // if eu vat is required, add the tax id field.\n      if (this.taxProtocol?.eu_vat_required) {\n        this.addTaxIDField();\n      }\n    }\n\n    // make sure to check order on load.\n    this.handleOrderChange();\n  }\n\n  addAddressField() {\n    if (this.hasAddress) return;\n    const payment = this.el.querySelector('sc-payment');\n    const address = document.createElement('sc-order-shipping-address');\n    address.label = __('Address', 'surecart');\n    payment.parentNode.insertBefore(address, payment);\n    this.hasAddress = true;\n  }\n\n  addTaxIDField() {\n    if (this.hasTaxIDField) return;\n    const payment = this.el.querySelector('sc-payment');\n    const taxInput = document.createElement('sc-order-tax-id-input');\n    taxInput.taxIdentifier?.number_type === 'eu_vat';\n    payment.parentNode.insertBefore(taxInput, payment);\n    this.hasTaxIDField = true;\n  }\n\n  addBumps() {\n    if (this.hasBumpsField) return;\n    const payment = this.el.querySelector('sc-payment');\n    const bumps = document.createElement('sc-order-bumps');\n    bumps.bumps === this.order?.recommended_bumps?.data;\n    payment.parentNode.insertBefore(bumps, payment.nextSibling);\n    this.hasBumpsField = true;\n  }\n\n  addTaxLine() {\n    if (this.hasTaxLine) return;\n    const total = this.el.querySelector('sc-line-item-total[total=total]');\n    const tax = document.createElement('sc-line-item-tax');\n    if (total?.previousElementSibling?.tagName === 'SC-DIVIDER') {\n      total.parentNode.insertBefore(tax, total.previousElementSibling);\n    } else {\n      total.parentNode.insertBefore(tax, total);\n    }\n    this.hasTaxLine = true;\n  }\n\n  render() {\n    return <slot />;\n  }\n}\n","import { Component, Event, EventEmitter, h, Listen, Prop, State, Watch, Element } from '@stencil/core';\nimport { __ } from '@wordpress/i18n';\n\nimport { FormState, FormStateSetter, ResponseError } from '../../../types';\n\n/**\n * This component listens for a confirmed event and redirects to the success url.\n */\n@Component({\n  tag: 'sc-form-error-provider',\n  shadow: true,\n})\nexport class ScFormErrorProvider {\n  /** The element. */\n  @Element() el: HTMLScFormErrorProviderElement;\n\n  /** The current order. */\n  @Prop() checkoutState: FormState;\n\n  /** Set the state. */\n  @Event() scUpdateError: EventEmitter<ResponseError>;\n\n  /** Form state event. */\n  @Event() scSetState: EventEmitter<FormStateSetter>;\n\n  /** Error to display. */\n  @State() error: ResponseError | null;\n\n  /** Trigger the error event when an error happens  */\n  @Watch('error')\n  handleErrorUpdate(val) {\n    this.scUpdateError.emit(val);\n  }\n\n  @Watch('checkoutState')\n  handleStateChange(val) {\n    if (['finalizing', 'updating'].includes(val)) {\n      this.error = null;\n    }\n  }\n\n  /** Listen for error events in component. */\n  @Listen('scError')\n  handleErrorEvent(e) {\n    this.error = e.detail as ResponseError;\n    if (Object.keys(e?.detail || {}).length) {\n      this.scSetState.emit('REJECT'); // make sure we are rejecting the current state.\n    }\n  }\n\n  /** Listen for pay errors. */\n  @Listen('scPayError')\n  handlePayError(e) {\n    this.error = e.detail?.message || {\n      code: '',\n      message: 'Something went wrong with your payment.',\n    };\n  }\n\n  componentWillLoad() {\n    this.maybeAddErrorsComponent();\n  }\n\n  maybeAddErrorsComponent() {\n    if (!!this.el.querySelector('sc-checkout-form-errors')) return;\n    const errorsComponent = document.createElement('sc-checkout-form-errors');\n    console.log(this.el.querySelector('sc-form'));\n    this.el.querySelector('sc-form').prepend(errorsComponent);\n  }\n\n  render() {\n    return <slot />;\n  }\n}\n","import { checkoutMachine } from '../../../src/components/providers/form-state-provider/checkout-machine';\nimport { interpret } from '@xstate/fsm';\nimport state from './store';\n\n// Start state machine.\nconst service = interpret(checkoutMachine);\nservice.subscribe(stateService => (state.formState = stateService));\nservice.start();\nexport default service;\n","import service from './watchers';\nconst { send } = service;\nexport const updateFormState = action => send(action);\n","import { Component, h, State, Event, EventEmitter, Listen, Watch } from '@stencil/core';\nimport { checkoutMachine } from './checkout-machine';\nimport { interpret } from '@xstate/fsm';\nimport { __ } from '@wordpress/i18n';\nimport { FormState, FormStateSetter } from '../../../types';\nimport { updateFormState } from '@store/form/mutations';\n\n/**\n * This component listens for a confirmed event and redirects to the success url.\n */\n@Component({\n  tag: 'sc-form-state-provider',\n  shadow: true,\n})\nexport class ScFormStateProvider {\n  /** Holds our state machine service */\n  private _stateService = interpret(checkoutMachine);\n\n  /** Loading states for different parts of the form. */\n  @State() checkoutState = checkoutMachine.initialState;\n\n  /** Set the state. */\n  @Event() scSetCheckoutFormState: EventEmitter<FormState>;\n\n  /** Set the state. */\n  setState(name) {\n    const { send } = this._stateService;\n    updateFormState(name);\n    return send(name);\n  }\n\n  /** Watch for checkout state changes and emit to listeners. */\n  @Watch('checkoutState')\n  handleCheckoutStateChange(state) {\n    this.scSetCheckoutFormState.emit(state.value);\n  }\n\n  /** Init the state service. */\n  componentWillLoad() {\n    // Start state machine.\n    this._stateService.subscribe(state => (this.checkoutState = state));\n    this._stateService.start();\n  }\n\n  /** Remove state machine on disconnect. */\n  disconnectedCallback() {\n    this._stateService.stop();\n  }\n\n  /** Allow children to set the form state. */\n  @Listen('scSetState')\n  handleSetStateEvent(e) {\n    this.setState(e.detail as FormStateSetter);\n  }\n\n  /** Update the state when the order is paid. */\n  @Listen('scPaid')\n  async handlePaid() {\n    this.setState('PAID');\n  }\n\n  render() {\n    // handle expired.\n    if (this.checkoutState.value === 'expired') {\n      return (\n        <sc-block-ui>\n          <div>{__('Please refresh the page.', 'surecart')}</div>\n        </sc-block-ui>\n      );\n    }\n\n    return <slot />;\n  }\n}\n",":host {\n  display: block;\n}\n","import { Component, Prop, h, Watch, State, Host, Listen, Event, EventEmitter } from '@stencil/core';\nimport { __ } from '@wordpress/i18n';\nimport apiFetch from '../../../functions/fetch';\nimport { Checkout } from '../../../types';\n\n@Component({\n  tag: 'sc-login-provider',\n  styleUrl: 'sc-login-provider.css',\n  shadow: true,\n})\nexport class ScLoginProvider {\n  private loginForm: HTMLScFormElement;\n\n  /** Is the user logged in. */\n  @Prop() loggedIn: boolean;\n  @Prop() order: Checkout;\n\n  @Event() scSetLoggedIn: EventEmitter<boolean>;\n  @Event() scSetCustomer: EventEmitter<{ email: string; name?: string }>;\n\n  @State() notice: boolean;\n  @State() open: boolean;\n  @State() loading: boolean;\n  @State() error: string;\n\n  /** Listen for open event. */\n  @Listen('scLoginPrompt')\n  handleLoginPrompt() {\n    this.open = true;\n  }\n\n  /** Focus on first input. */\n  @Watch('open')\n  handleLoginDialogChange(val) {\n    if (val) {\n      setTimeout(() => {\n        this.loginForm.querySelector('sc-input').triggerFocus();\n      }, 100);\n    }\n  }\n\n  @Watch('loggedIn')\n  handleLoggedInChange(val, prev) {\n    if (prev === false && val) {\n      this.notice = true;\n    }\n  }\n\n  @Watch('order')\n  handleOrderChange(val, prev) {\n    if (val?.updated_at !== prev?.updated_at) {\n      this.notice = false;\n    }\n  }\n\n  /** Handle form submit. */\n  async handleFormSubmit(e) {\n    e.preventDefault();\n    e.stopImmediatePropagation();\n    this.error = null;\n\n    const { login, password } = await e.target.getFormJson();\n\n    try {\n      this.loading = true;\n      const { name, email } = (await apiFetch({\n        method: 'POST',\n        path: 'surecart/v1/login',\n        data: {\n          login,\n          password,\n        },\n      })) as { name: string; email: string };\n      this.scSetLoggedIn.emit(true);\n      this.scSetCustomer.emit({ name, email });\n      this.open = false;\n    } catch (e) {\n      console.error(e);\n      this.error = e?.message || __('Something went wrong', 'surecart');\n    } finally {\n      this.loading = false;\n    }\n  }\n\n  render() {\n    return (\n      <Host>\n        {!!this.notice && (\n          <sc-alert type=\"success\" open style={{ marginBottom: 'var(--sc-form-row-spacing)' }} closable>\n            <span slot=\"title\">{__('Welcome back!', 'surecart')}</span>\n            {__('You have logged in successfully.', 'surecart')}\n          </sc-alert>\n        )}\n\n        <slot />\n\n        {!this.loggedIn && (\n          <sc-dialog label={__('Login to your account', 'surecart')} open={this.open} onScRequestClose={() => (this.open = false)}>\n            <sc-form\n              ref={el => (this.loginForm = el as HTMLScFormElement)}\n              onScFormSubmit={e => {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n              }}\n              onScSubmit={e => this.handleFormSubmit(e)}\n            >\n              {!!this.error && (\n                <sc-alert type=\"danger\" open={!!this.error}>\n                  {this.error}\n                </sc-alert>\n              )}\n              <sc-input label={__('Email or Username', 'surecart')} type=\"text\" name=\"login\" required autofocus={this.open}></sc-input>\n              <sc-input label={__('Password', 'surecart')} type=\"password\" name=\"password\" required></sc-input>\n              <sc-button type=\"primary\" full loading={this.loading} submit>\n                {__('Login', 'surecart')}\n              </sc-button>\n            </sc-form>\n          </sc-dialog>\n        )}\n      </Host>\n    );\n  }\n}\n",".confirm {\n  &__icon {\n    margin-bottom: var(--sc-spacing-medium);\n    display: flex;\n    justify-content: center;\n  }\n\n  &__icon-container {\n    background: var(--sc-color-primary-500);\n    width: 55px;\n    height: 55px;\n    border-radius: 999999px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 26px;\n    line-height: 1;\n    color: white;\n  }\n}\n\nsc-dialog::part(overlay) {\n  backdrop-filter: blur(4px);\n}\n","import { Component, Element, Event, EventEmitter, h, Host, Listen, Prop, State } from '@stencil/core';\nimport { __ } from '@wordpress/i18n';\nimport { addQueryArgs } from '@wordpress/url';\n\nimport apiFetch from '../../../functions/fetch';\nimport { expand } from '../../../services/session';\nimport { state as checkoutState } from '@store/checkout';\nimport { Checkout, ManualPaymentMethod, Product } from '../../../types';\nimport { clearCheckout } from '@store/checkout/mutations';\nimport { maybeConvertAmount } from '../../../functions/currency';\n\n/**\n * This component listens to the order status\n * and confirms the order when payment is successful.\n */\n@Component({\n  tag: 'sc-order-confirm-provider',\n  styleUrl: 'sc-order-confirm-provider.scss',\n  shadow: true,\n})\nexport class ScOrderConfirmProvider {\n  /** The order confirm provider element */\n  @Element() el: HTMLScOrderConfirmProviderElement;\n\n  /** Whether to show success modal */\n  @State() showSuccessModal: boolean = false;\n\n  @State() confirmedCheckout: Checkout;\n\n  /** Success url. */\n  @Prop() successUrl: string;\n\n  /** Success text for the form. */\n  @Prop() successText: {\n    title: string;\n    description: string;\n    button: string;\n  };\n\n  /** The order is paid event. */\n  @Event() scOrderPaid: EventEmitter<Checkout>;\n\n  @Event() scSetState: EventEmitter<string>;\n\n  /** Error event. */\n  @Event() scError: EventEmitter<{ message: string; code?: string; data?: any; additional_errors?: any } | {}>;\n\n  /** Listen for paid event. This is triggered by Stripe or Paypal elements when payment succeeds. */\n  @Listen('scPaid')\n  handlePaidEvent() {\n    this.confirmOrder();\n  }\n\n  /** Confirm the order. */\n  async confirmOrder() {\n    try {\n      this.confirmedCheckout = (await apiFetch({\n        method: 'PATCH',\n        path: addQueryArgs(`surecart/v1/checkouts/${checkoutState?.checkout?.id}/confirm`, { expand }),\n      })) as Checkout;\n      this.scSetState.emit('CONFIRMED');\n      // emit the order paid event for tracking scripts.\n      this.scOrderPaid.emit(this.confirmedCheckout);\n      this.doGoogleAnalytics();\n    } catch (e) {\n      console.error(e);\n      this.scError.emit(e);\n    } finally {\n      // always clear the checkout.\n      clearCheckout();\n      // get success url.\n      const successUrl = this.confirmedCheckout?.metadata?.success_url || this.successUrl;\n      if (successUrl) {\n        // set state to redirecting.\n        this.scSetState.emit('REDIRECT');\n        setTimeout(() => window.location.assign(addQueryArgs(successUrl, { order: this.confirmedCheckout?.id })), 50);\n      } else {\n        this.showSuccessModal = true;\n      }\n    }\n  }\n\n  doGoogleAnalytics() {\n    if (!window?.dataLayer && !window?.gtag) return;\n\n    const data = {\n      transaction_id: this.confirmedCheckout?.id,\n      value: maybeConvertAmount(this.confirmedCheckout?.total_amount, this.confirmedCheckout?.currency || 'USD'),\n      currency: (this.confirmedCheckout.currency || '').toUpperCase(),\n      ...(this.confirmedCheckout?.discount?.promotion?.code ? { coupon: this.confirmedCheckout?.discount?.promotion?.code } : {}),\n      ...(this.confirmedCheckout?.tax_amount ? { tax: maybeConvertAmount(this.confirmedCheckout?.tax_amount, this.confirmedCheckout?.currency || 'USD') } : {}),\n      items: (this.confirmedCheckout?.line_items?.data || []).map(item => ({\n        item_name: (item?.price?.product as Product)?.name || '',\n        discount: item?.discount_amount ? maybeConvertAmount(item?.discount_amount || 0, this.confirmedCheckout?.currency || 'USD') : 0,\n        price: maybeConvertAmount(item?.price?.amount || 0, this.confirmedCheckout?.currency || 'USD'),\n        quantity: item?.quantity || 1,\n      })),\n    };\n\n    // handle gtag (analytics script.)\n    if (window?.gtag) {\n      window.gtag('event', 'purchase', data);\n    }\n\n    // handle dataLayer (google tag manager).\n    if (window?.dataLayer) {\n      window.dataLayer.push({ ecommerce: null }); // Clear the previous ecommerce object.\n      window.dataLayer.push({\n        event: 'purchase',\n        ecommerce: data,\n      });\n    }\n  }\n\n  getSuccessUrl() {\n    const url = this.confirmedCheckout?.metadata?.success_url || this.successUrl;\n    return url ? addQueryArgs(url, { order: this.confirmedCheckout?.id }) : window?.scData?.pages?.dashboard;\n  }\n\n  render() {\n    const manualPaymentMethod = this.confirmedCheckout?.manual_payment_method as ManualPaymentMethod;\n\n    return (\n      <Host>\n        <slot />\n        <sc-dialog open={!!this.showSuccessModal} style={{ '--body-spacing': 'var(--sc-spacing-xxx-large)' }} noHeader onScRequestClose={e => e.preventDefault()}>\n          <div class=\"confirm__icon\">\n            <div class=\"confirm__icon-container\">\n              <sc-icon name=\"check\" />\n            </div>\n          </div>\n          <sc-dashboard-module\n            heading={this.successText?.title || __('Thanks for your order!', 'surecart')}\n            style={{ '--sc-dashboard-module-spacing': 'var(--sc-spacing-x-large)', 'textAlign': 'center' }}\n          >\n            <span slot=\"description\">\n              {this.successText?.description || __('Your payment was successful, and your order is complete. A receipt is on its way to your inbox.', 'surecart')}\n            </span>\n            {!!manualPaymentMethod?.name && !!manualPaymentMethod?.instructions && (\n              <sc-alert type=\"info\" open style={{ 'text-align': 'left' }}>\n                <span slot=\"title\">{manualPaymentMethod?.name}</span>\n                {manualPaymentMethod?.instructions.split('\\n').map(i => {\n                  return <p>{i}</p>;\n                })}\n              </sc-alert>\n            )}\n            <sc-button href={this.getSuccessUrl()} size=\"large\" type=\"primary\">\n              {this.successText?.button || __('Continue', 'surecart')}\n              <sc-icon name=\"arrow-right\" slot=\"suffix\" />\n            </sc-button>\n          </sc-dashboard-module>\n        </sc-dialog>\n      </Host>\n    );\n  }\n}\n","import { Component, Element, Event, EventEmitter, h, Listen, Method, Prop, Watch } from '@stencil/core';\nimport { state as checkoutState } from '@store/checkout';\nimport { clearCheckout } from '@store/checkout/mutations';\nimport { state as selectedProcessor } from '@store/selected-processor';\nimport { __ } from '@wordpress/i18n';\nimport { addQueryArgs, getQueryArg, getQueryArgs, removeQueryArgs } from '@wordpress/url';\nimport { updateFormState } from '@store/form/mutations';\n\nimport { parseFormData } from '../../../functions/form-data';\nimport { createOrUpdateCheckout, fetchCheckout, finalizeCheckout } from '../../../services/session';\nimport { Checkout, FormStateSetter, LineItemData, PriceChoice } from '../../../types';\n\n@Component({\n  tag: 'sc-session-provider',\n  shadow: true,\n})\nexport class ScSessionProvider {\n  /** Element */\n  @Element() el: HTMLElement;\n\n  /** An array of prices to pre-fill in the form. */\n  @Prop() prices: Array<PriceChoice> = [];\n\n  /** Should we persist the session. */\n  @Prop() persist: boolean = true;\n\n  /** Update line items event */\n  @Event() scUpdateOrderState: EventEmitter<Checkout>;\n\n  /** Update line items event */\n  @Event() scUpdateDraftState: EventEmitter<Checkout>;\n\n  @Event() scPaid: EventEmitter<void>;\n\n  /** Error event */\n  @Event() scError: EventEmitter<{ message: string; code?: string; data?: any; additional_errors?: any } | {}>;\n\n  /** Set the state */\n  @Event() scSetState: EventEmitter<FormStateSetter>;\n\n  @Watch('prices')\n  handlePricesChange() {\n    let line_items = this.addInitialPrices() || [];\n    line_items = this.addPriceChoices(line_items);\n    if (!line_items?.length) {\n      return;\n    }\n    return this.loadUpdate({ line_items });\n  }\n\n  /**\n   * Finalize the order.\n   *\n   * @returns {Promise<Order>}\n   */\n  @Method()\n  async finalize() {\n    return await this.handleFormSubmit();\n  }\n\n  async getFormData() {\n    let data = {};\n    const form = this.el.querySelector('sc-form');\n    if (form) {\n      const json = await form.getFormJson();\n      data = parseFormData(json);\n    }\n    return data;\n  }\n\n  /**\n   * Handles the form submission.\n   * @param e\n   */\n  @Listen('scFormSubmit')\n  async handleFormSubmit() {\n    this.scError.emit({});\n\n    updateFormState('FINALIZE');\n\n    // Get current form state.\n    let data = await this.getFormData();\n\n    if (window?.scData?.recaptcha_site_key && window?.grecaptcha) {\n      try {\n        data['grecaptcha'] = await window.grecaptcha.execute(window.scData.recaptcha_site_key, { action: 'surecart_checkout_submit' });\n      } catch (e) {\n        console.error(e);\n        updateFormState('REJECT');\n        this.handleErrorResponse(e);\n        return;\n      }\n    }\n\n    // first lets make sure the session is updated before we process it.\n    try {\n      await this.update(data);\n    } catch (e) {\n      console.error(e);\n      updateFormState('REJECT');\n      this.handleErrorResponse(e);\n    }\n\n    // first validate server-side and get key\n    try {\n      checkoutState.checkout = await finalizeCheckout({\n        id: checkoutState?.checkout?.id,\n        query: {\n          ...(selectedProcessor?.method ? { payment_method_type: selectedProcessor?.method } : {}),\n          return_url: addQueryArgs(window.location.href, {\n            ...(checkoutState?.checkout?.id ? { checkout_id: checkoutState?.checkout?.id } : {}),\n            is_surecart_payment_redirect: true,\n          }),\n        },\n        data,\n        processor: {\n          id: selectedProcessor.id,\n          manual: selectedProcessor.manual,\n        },\n      });\n\n      // the checkout is paid.\n      if (['paid', 'processing'].includes(checkoutState.checkout?.status)) {\n        this.scPaid.emit();\n      }\n\n      if (checkoutState.checkout?.payment_intent?.processor_data?.mollie?.checkout_url) {\n        updateFormState('PAYING');\n        return setTimeout(() => window.location.assign(checkoutState.checkout?.payment_intent?.processor_data?.mollie?.checkout_url), 50);\n      }\n\n      setTimeout(() => {\n        updateFormState('PAYING');\n      }, 50);\n\n      return checkoutState.checkout;\n    } catch (e) {\n      console.error(e);\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /**\n   * Handle paid event and update the\n   */\n  @Listen('scPaid')\n  async handlePaid() {\n    updateFormState('PAID');\n  }\n\n  @Listen('scPayError')\n  async handlePayError() {\n    updateFormState('REJECT');\n  }\n\n  @Listen('scUpdateAbandonedCart')\n  async handleAbandonedCartUpdate(e) {\n    const abandoned_checkout_enabled = e.detail;\n    this.loadUpdate({\n      abandoned_checkout_enabled,\n    });\n  }\n\n  /** Handles coupon updates. */\n  @Listen('scApplyCoupon')\n  async handleCouponApply(e) {\n    const promotion_code = e.detail;\n    this.scError.emit({});\n    this.loadUpdate({\n      discount: {\n        ...(promotion_code ? { promotion_code } : {}),\n      },\n    });\n  }\n\n  /** Find or create session on load. */\n  componentDidLoad() {\n    this.findOrCreateOrder();\n  }\n\n  /** Find or create an order */\n  async findOrCreateOrder() {\n    // get URL params.\n    const { redirect_status, checkout_id, line_items, coupon, is_surecart_payment_redirect } = getQueryArgs(window.location.href);\n    // remove params we don't want.\n    window.history.replaceState({}, document.title, removeQueryArgs(window.location.href, 'redirect_status', 'coupon', 'line_items', 'confirm_checkout_id', 'checkout_id'));\n\n    // handle abandoned checkout.\n    if (!!is_surecart_payment_redirect && !!checkout_id) {\n      updateFormState('FINALIZE');\n      updateFormState('PAYING');\n      return this.handleCheckoutIdFromUrl(checkout_id, coupon as string);\n    }\n\n    // handle redirect status.\n    if (!!redirect_status) {\n      return this.handleRedirectStatus(redirect_status, checkout_id);\n    }\n\n    // handle abandoned checkout.\n    if (!!checkout_id) {\n      return this.handleCheckoutIdFromUrl(checkout_id, coupon as string);\n    }\n\n    // handle initial line items.\n    if (!!line_items) {\n      return this.handleInitialLineItems(line_items, coupon as string);\n    }\n\n    // we have an existing saved checkout id in the session, and we are persisting.\n    const id = checkoutState?.checkout?.id;\n    if (id && this.persist) {\n      return this.handleExistingCheckout(id, coupon as string);\n    }\n\n    return this.handleNewCheckout(coupon as string);\n  }\n\n  /** Handle payment instrument redirect status */\n  async handleRedirectStatus(status, id) {\n    console.info('Handling payment redirect.');\n    // status failed.\n    if (status === 'failed') {\n      return this.scError.emit({\n        message: __('Payment unsuccessful. Please try again.', 'surecart'),\n      });\n    }\n\n    // get the\n    if (!id) {\n      return this.scError.emit({\n        message: __('Could not find checkout. Please contact us before attempting to purchase again.', 'surecart'),\n      });\n    }\n\n    // success, refetch the checkout\n    try {\n      updateFormState('FINALIZE');\n      updateFormState('PAID');\n      checkoutState.checkout = (await fetchCheckout({\n        id,\n        query: {\n          refresh_status: true,\n        },\n      })) as Checkout;\n\n      // TODO: should we even check this?\n      if (checkoutState.checkout?.status && ['paid', 'processing'].includes(checkoutState.checkout?.status)) {\n        setTimeout(() => {\n          this.scPaid.emit();\n        }, 100);\n      }\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Handle abandoned checkout from URL */\n  async handleCheckoutIdFromUrl(id, promotion_code = '') {\n    console.info('Handling existing checkout from url.', promotion_code, id);\n\n    // if coupon code, load the checkout with the code.\n    if (promotion_code) {\n      return this.loadUpdate({\n        id,\n        discount: { promotion_code },\n        refresh_price_versions: true,\n      });\n    }\n\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await fetchCheckout({\n        id,\n        query: {\n          refresh_status: true,\n        },\n      })) as Checkout;\n      updateFormState('RESOLVE');\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n\n    // handle status.\n    switch (checkoutState.checkout?.status) {\n      case 'paid':\n      case 'processing':\n        return setTimeout(() => {\n          updateFormState('FINALIZE');\n          updateFormState('PAID');\n          this.scPaid.emit();\n        }, 100);\n\n      case 'payment_failed':\n        clearCheckout();\n        return this.scError.emit({\n          message: __('Payment unsuccessful. Please try again.', 'surecart'),\n        });\n\n      case 'payment_intent_canceled':\n      case 'canceled':\n        clearCheckout();\n        return this.scError.emit({\n          message: __('Payment canceled. Please try again.', 'surecart'),\n        });\n\n      case 'finalized':\n        this.scError.emit({\n          message: __('Payment unsuccessful. Please try again.', 'surecart'),\n        });\n        updateFormState('REJECT');\n    }\n  }\n\n  /** Handle line items (and maybe ) */\n  async handleInitialLineItems(line_items, promotion_code) {\n    console.info('Handling initial line items.');\n    // TODO: move this to central store.\n    const address = this.el.querySelector('sc-order-shipping-address');\n    clearCheckout();\n    return this.loadUpdate({\n      line_items,\n      refresh_price_versions: true,\n      ...(promotion_code ? { discount: { promotion_code } } : {}),\n      ...(address?.defaultCountry\n        ? {\n            shipping_address: {\n              country: address?.defaultCountry,\n            },\n          }\n        : {}),\n    });\n  }\n\n  /** Handle a brand new checkout. */\n  async handleNewCheckout(promotion_code) {\n    console.info('Handling new checkout.');\n    // get existing form data from defaults (default country selection, etc).\n    const data = this.getFormData();\n    const line_items = this.addPriceChoices(this.addInitialPrices() || []);\n    const address = this.el.querySelector('sc-order-shipping-address');\n\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await createOrUpdateCheckout({\n        data: {\n          ...data,\n          ...(promotion_code ? { discount: { promotion_code } } : {}),\n          ...(address?.defaultCountry\n            ? {\n                shipping_address: {\n                  country: address?.defaultCountry,\n                },\n              }\n            : {}),\n          line_items,\n        },\n      })) as Checkout;\n      updateFormState('RESOLVE');\n    } catch (e) {\n      console.error(e);\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Handle existing checkout */\n  async handleExistingCheckout(id, promotion_code) {\n    if (!id) return this.handleNewCheckout(promotion_code);\n    console.info('Handling existing checkout.');\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await createOrUpdateCheckout({\n        id,\n        data: {\n          ...(promotion_code ? { discount: { promotion_code } } : {}),\n          refresh_price_versions: true,\n        },\n      })) as Checkout;\n      updateFormState('RESOLVE');\n    } catch (e) {\n      console.error(e);\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Handle the error response. */\n  async handleErrorResponse(e) {\n    // reinitalize if order not found.\n    if (['checkout.not_found'].includes(e?.code)) {\n      window.history.replaceState({}, document.title, removeQueryArgs(window.location.href, 'checkout_id'));\n      clearCheckout();\n      return this.handleNewCheckout(false);\n    }\n\n    if (e?.additional_errors?.[0]?.code === 'order.line_items.old_price_versions') {\n      await this.loadUpdate({\n        id: checkoutState?.checkout?.id,\n        data: {\n          status: 'draft',\n          refresh_price_versions: true,\n        },\n      });\n      return;\n    }\n\n    if (['order.invalid_status_transition'].includes(e?.code)) {\n      await this.loadUpdate({\n        id: checkoutState?.checkout?.id,\n        data: {\n          status: 'draft',\n        },\n      });\n      this.handleFormSubmit();\n      return;\n    }\n\n    // expired\n    if (e?.code === 'rest_cookie_invalid_nonce') {\n      updateFormState('EXPIRE');\n      return;\n    }\n\n    // paid\n    if (e?.code === 'readonly') {\n      clearCheckout();\n      window.location.assign(removeQueryArgs(window.location.href, 'order'));\n      return;\n    }\n\n    console.log('emit', e);\n    this.scError.emit(e);\n    updateFormState('REJECT');\n  }\n\n  /** Looks through children and finds items needed for initial session. */\n  async initialize(args = {}) {\n    let line_items = this.addInitialPrices() || [];\n    line_items = this.addPriceChoices(line_items);\n\n    if (line_items?.length) {\n      return this.loadUpdate({ line_items, ...args });\n    } else {\n      return this.loadUpdate({ ...args });\n    }\n  }\n\n  /** Add prices that are passed into the component. */\n  addInitialPrices() {\n    if (!this?.prices?.length) return [];\n\n    // check for id\n    if (this.prices.some(p => !p?.id)) {\n      return;\n    }\n\n    // add prices that are passed into this component.\n    return this.prices.map(price => {\n      return {\n        price_id: price.id,\n        quantity: price.quantity,\n      };\n    });\n  }\n\n  /** Add default prices that may be selected in form. */\n  addPriceChoices(line_items = []) {\n    const elements = this.el.querySelectorAll('[price-id]') as any;\n\n    elements.forEach(el => {\n      // handle price choices.\n      if (el.checked) {\n        line_items.push({\n          quantity: el.quantity || 1,\n          price_id: el.priceId,\n          ...(el.defaultAmount ? { ad_hoc_amount: el.defaultAmount } : {}),\n        });\n      }\n      // handle donation default amount.\n      if (el.defaultAmount) {\n        line_items.push({\n          quantity: el.quantity || 1,\n          price_id: el.priceId,\n          ad_hoc_amount: el.defaultAmount,\n        });\n      }\n    });\n\n    return line_items;\n  }\n\n  getSessionId() {\n    // check url first.\n    const checkoutId = getQueryArg(window.location.href, 'checkout_id');\n    if (!!checkoutId) {\n      return checkoutId;\n    }\n\n    // check existing order.\n    if (checkoutState?.checkout?.id) {\n      return checkoutState?.checkout?.id;\n    }\n\n    // we don't have and order id.\n    return null;\n  }\n\n  async fetchCheckout(id, { query = {}, data = {} } = {}) {\n    try {\n      updateFormState('FETCH');\n      const checkout = (await createOrUpdateCheckout({\n        id,\n        query,\n        data,\n      })) as Checkout;\n      updateFormState('RESOLVE');\n      return checkout;\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Fetch a session. */\n  async fetch(query = {}) {\n    try {\n      updateFormState('FETCH');\n      checkoutState.checkout = (await fetchCheckout({\n        id: this.getSessionId(),\n        query,\n      })) as Checkout;\n      updateFormState('RESOLVE');\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  /** Update a session */\n  async update(data: any = {}, query = {}) {\n    try {\n      checkoutState.checkout = (await createOrUpdateCheckout({\n        id: data?.id ? data.id : this.getSessionId(),\n        data,\n        query,\n      })) as Checkout;\n    } catch (e) {\n      // reinitalize if order not found.\n      if (['checkout.not_found'].includes(e?.code)) {\n        clearCheckout();\n        return this.initialize();\n      }\n      console.error(e);\n      throw e;\n    }\n  }\n\n  /** Updates a session with loading status changes. */\n  async loadUpdate(data = {}) {\n    try {\n      updateFormState('FETCH');\n      await this.update(data);\n      updateFormState('RESOLVE');\n    } catch (e) {\n      this.handleErrorResponse(e);\n    }\n  }\n\n  render() {\n    return (\n      <sc-line-items-provider order={checkoutState?.checkout} onScUpdateLineItems={e => this.loadUpdate({ line_items: e.detail as Array<LineItemData> })}>\n        <slot />\n      </sc-line-items-provider>\n    );\n  }\n}\n"],"version":3}